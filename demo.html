<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SporkServices - Our Web Dev</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüñ•Ô∏è%3C/text%3E%3C/svg%3E">
    <meta name="description" content="Interactive web development demos showcasing SporkServices' custom coding skills with HTML5 Canvas.">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">üñ•Ô∏è SporkServices</div>
            <button class="hamburger" id="hamburger-button" aria-label="Toggle navigation menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul id="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="#demos">Demos</a></li>
                <li><a href="index.html#services">Services</a></li>
                <li><a href="index.html#about">About</a></li>
                <li><a href="index.html#portfolio">Portfolio</a></li>
                <li><a href="index.html#testimonials">Testimonials</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
            <button id="theme-toggle" aria-label="Toggle dark mode">üåô</button>
        </nav>
    </header>

    <main>
        <section id="hero" class="hero">
            <h1>Our Web Dev</h1>
            <p>Explore interactive examples of our custom coding work using HTML5 Canvas</p>
        </section>

        <section id="demos" class="services">
            <h2>Our Web Dev Demos</h2>
            <div class="demo-grid">
                <div class="demo-card">
                    <h3>Bouncing Balls</h3>
                    <canvas id="bouncing-canvas" width="400" height="300"></canvas>
                    <p>A simple physics simulation demonstrating animation and collision detection.</p>
                </div>
                <div class="demo-card">
                    <h3>Particle System</h3>
                    <canvas id="particle-canvas" width="400" height="300"></canvas>
                    <p>Dynamic particle effects for visual appeal in web applications.</p>
                </div>
                <div class="demo-card">
                    <h3>Animated Text</h3>
                    <canvas id="text-canvas" width="400" height="300"></canvas>
                    <p>Creative text animations for engaging user interfaces.</p>
                </div>
                <div class="demo-card">
                    <h3>3D Rotating Cube (WebGL)</h3>
                    <canvas id="webgl-canvas" width="400" height="300"></canvas>
                    <p>Bleeding-edge 3D graphics using WebGL for immersive web experiences.</p>
                </div>
                <div class="demo-card">
                    <h3>Real-Time Collaborative Drawing</h3>
                    <div>
                        <input type="text" id="room-input" placeholder="Enter room ID" style="margin-right: 10px;">
                        <button id="connect-room">Connect</button>
                        <button id="clear-drawing">Clear</button>
                    </div>
                    <canvas id="drawing-canvas" width="400" height="300" style="border: 1px solid #ccc;"></canvas>
                    <p>Multi-user collaborative drawing - connect to a room to draw with others in real-time using WebRTC.</p>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>¬© 2025 SporkServices. All rights reserved.</p>
        <div class="social-links">
            <a href="https://www.facebook.com/sporkservices" aria-label="Facebook">Facebook</a>
            <a href="https://www.twitter.com/sporkservices" aria-label="Twitter">Twitter</a>
            <a href="https://www.linkedin.com/company/sporkservices" aria-label="LinkedIn">LinkedIn</a>
        </div>
        <p>Ready to upgrade your tech? <a href="contact.html" style="color: white; text-decoration: underline;">Contact us today!</a></p>
    </footer>

    <script src="script.js"></script>
    <script>
        // Bouncing Balls Demo
        const bouncingCanvas = document.getElementById('bouncing-canvas');
        const bouncingCtx = bouncingCanvas.getContext('2d');

        let balls = [];
        for (let i = 0; i < 5; i++) {
            balls.push({
                x: Math.random() * 350 + 25,
                y: Math.random() * 250 + 25,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                radius: 20,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`
            });
        }

        function animateBouncing() {
            bouncingCtx.clearRect(0, 0, 400, 300);
            balls.forEach(ball => {
                ball.x += ball.vx;
                ball.y += ball.vy;

                if (ball.x - ball.radius < 0 || ball.x + ball.radius > 400) ball.vx *= -1;
                if (ball.y - ball.radius < 0 || ball.y + ball.radius > 300) ball.vy *= -1;

                bouncingCtx.beginPath();
                bouncingCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                bouncingCtx.fillStyle = ball.color;
                bouncingCtx.fill();
            });
            requestAnimationFrame(animateBouncing);
        }
        animateBouncing();

        // Particle System Demo
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');

        let particles = [];
        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * 400,
                y: Math.random() * 300,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: Math.random() * 100 + 50
            });
        }

        function animateParticles() {
            particleCtx.clearRect(0, 0, 400, 300);
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                if (p.life <= 0) {
                    particles[i] = {
                        x: Math.random() * 400,
                        y: Math.random() * 300,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: Math.random() * 100 + 50
                    };
                }

                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                particleCtx.fillStyle = `rgba(0, 123, 255, ${p.life / 150})`;
                particleCtx.fill();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        // Animated Text Demo
        const textCanvas = document.getElementById('text-canvas');
        const textCtx = textCanvas.getContext('2d');

        let text = "SporkServices";
        let textIndex = 0;
        let displayText = "";

        function animateText() {
            textCtx.clearRect(0, 0, 400, 300);
            textCtx.font = "2rem Arial";
            textCtx.fillStyle = "white";
            textCtx.textAlign = "center";

            if (textIndex < text.length) {
                displayText += text[textIndex];
                textIndex++;
            }

            textCtx.fillText(displayText, 200, 150);

            // Add some glow effect
            textCtx.shadowColor = "blue";
            textCtx.shadowBlur = 10;
            textCtx.fillText(displayText, 200, 150);

            if (textIndex < text.length || Math.random() < 0.01) {
                requestAnimationFrame(animateText);
            } else {
                setTimeout(() => {
                    textIndex = 0;
                    displayText = "";
                    animateText();
                }, 2000);
            }
        }
        animateText();

        // WebGL 3D Rotating Cube Demo
        const webglCanvas = document.getElementById('webgl-canvas');
        const gl = webglCanvas.getContext('webgl');

        if (!gl) {
            console.error('WebGL not supported');
            return;
        }

        // Vertex shader
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec4 aColor;
            uniform mat4 uMatrix;
            varying vec4 vColor;
            void main() {
                gl_Position = uMatrix * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        // Fragment shader
        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 vColor;
            void main() {
                gl_FragColor = vColor;
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Error linking program:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return;
        }

        gl.useProgram(program);

        // Cube vertices
        const positions = [
            // Front face
            -1, -1,  1,
             1, -1,  1,
             1,  1,  1,
            -1,  1,  1,
            // Back face
            -1, -1, -1,
            -1,  1, -1,
             1,  1, -1,
             1, -1, -1,
            // Top face
            -1,  1, -1,
            -1,  1,  1,
             1,  1,  1,
             1,  1, -1,
            // Bottom face
            -1, -1, -1,
             1, -1, -1,
             1, -1,  1,
            -1, -1,  1,
            // Right face
             1, -1, -1,
             1,  1, -1,
             1,  1,  1,
             1, -1,  1,
            // Left face
            -1, -1, -1,
            -1, -1,  1,
            -1,  1,  1,
            -1,  1, -1,
        ];

        const colors = [
            // Front face (red)
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            // Back face (green)
            0, 1, 0, 1,
            0, 1, 0, 1,
            0, 1, 0, 1,
            0, 1, 0, 1,
            // Top face (blue)
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            // Bottom face (yellow)
            1, 1, 0, 1,
            1, 1, 0, 1,
            1, 1, 0, 1,
            1, 1, 0, 1,
            // Right face (purple)
            1, 0, 1, 1,
            1, 0, 1, 1,
            1, 0, 1, 1,
            1, 0, 1, 1,
            // Left face (cyan)
            0, 1, 1, 1,
            0, 1, 1, 1,
            0, 1, 1, 1,
            0, 1, 1, 1,
        ];

        const indices = [
            0,  1,  2,    0,  2,  3,  // front
            4,  5,  6,    4,  6,  7,  // back
            8,  9, 10,    8, 10, 11,  // top
           12, 13, 14,   12, 14, 15,  // bottom
           16, 17, 18,   16, 18, 19,  // right
           20, 21, 22,   20, 22, 23,  // left
        ];

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        const colorLocation = gl.getAttribLocation(program, 'aColor');
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        const matrixLocation = gl.getUniformLocation(program, 'uMatrix');

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 1);

        let rotation = 0;

        function animateWebGL() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const aspect = 400 / 300;
            const projectionMatrix = [
                1/aspect, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, -1, -0.1,
                0, 0, -1, 0
            ];

            const rotationMatrix = [
                Math.cos(rotation), 0, Math.sin(rotation), 0,
                0, 1, 0, 0,
                -Math.sin(rotation), 0, Math.cos(rotation), 0,
                0, 0, 0, 1
            ];

            const matrix = multiplyMatrices(projectionMatrix, rotationMatrix);

            gl.uniformMatrix4fv(matrixLocation, false, matrix);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            rotation += 0.01;
            requestAnimationFrame(animateWebGL);
        }

        function multiplyMatrices(a, b) {
            const result = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = a[i * 4] * b[j] + a[i * 4 + 1] * b[j + 4] + a[i * 4 + 2] * b[j + 8] + a[i * 4 + 3] * b[j + 12];
                }
            }
            return result;
        }

        animateWebGL();

        // Real-Time Collaborative Drawing Demo
        const drawingCanvas = document.getElementById('drawing-canvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const clearButton = document.getElementById('clear-drawing');
        const connectButton = document.getElementById('connect-room');
        const roomInput = document.getElementById('room-input');

        drawingCtx.lineWidth = 5;
        drawingCtx.lineCap = 'round';
        drawingCtx.strokeStyle = 'blue';

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let peerConnection = null;
        let dataChannel = null;

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing) return;
            const currentX = e.offsetX;
            const currentY = e.offsetY;
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(currentX, currentY);
            drawingCtx.stroke();
            [lastX, lastY] = [currentX, currentY];

            // Send drawing data to peer
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'draw', fromX: lastX, fromY: lastY, toX: currentX, toY: currentY }));
            }
        }

        function stopDrawing() {
            isDrawing = false;
        }

        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        clearButton.addEventListener('click', () => {
            drawingCtx.clearRect(0, 0, 400, 300);
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'clear' }));
            }
        });

        connectButton.addEventListener('click', async () => {
            const roomId = roomInput.value;
            if (!roomId) return;

            // For demo purposes, use a simple signaling via localStorage (not true real-time for multiple users)
            // In a real app, use a signaling server
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            dataChannel = peerConnection.createDataChannel('drawing');
            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'draw') {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(data.fromX, data.fromY);
                    drawingCtx.lineTo(data.toX, data.toY);
                    drawingCtx.stroke();
                } else if (data.type === 'clear') {
                    drawingCtx.clearRect(0, 0, 400, 300);
                }
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // In real app, send to signaling server
                    console.log('ICE candidate:', event.candidate);
                }
            };

            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // For demo, alert the offer (in real app, send to peer via signaling)
            alert('Copy this offer and send to peer: ' + JSON.stringify(offer));

            // Listen for answer (mock)
            // This is simplified; real implementation needs signaling server
        });

        // Mock answer handling (in real app, receive from signaling)
        window.receiveAnswer = async (answer) => {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));
        };
    </script>
</body>
</html>